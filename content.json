[{"title":"设计模式","slug":null,"date":"2017-03-22T13:18:03.000Z","updated":null,"comments":null,"path":"2017/03/22/Design-pattern/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"设计模式是一套被反复使用、思想成熟、经过分类和无数实战设计经验总结的。为了让系统代码可重用、可扩展、可解耦。设计模式使代码开发真正工程化。 设计原则 [开闭原则] 对扩展开放，对修改关闭。(试卷附加题)[里氏转换原则] 子类继承父类，单独可运行。(盗版光盘)[依赖倒转原则] 引用一个对象，如果对象有底层类型，直接引用底层。(打井水)[接口隔离原则] 每一个接口为一种角色。(USB插头)[合成/聚合复用原则] 新对象应使用已有对象，使之成为新对象的一部分。(旧零件组装新物品)[迪米特原则] 一个对象应对其他对象有尽可能少的了解。(只对自己对象深入了解) 单例模式 单例模式：保证一个类只有一个实例，先判断实例是否存在，存在则直接返回，如果不存在就创建后再返回。 两个对象间的通信(B对A发出一个不为空的消息，A返回”Thank you B!”消息) 1234567891011121314151617var A = (function()&#123; //匿名函数自执行，return 1个对象 return &#123; receiveMsg: function(msg)&#123; if(msg)&#123; return \"Thank you B!\"; &#125; &#125; &#125;&#125;)();var B = &#123; //对象字面量直接定义 callA: function(msg)&#123; return A.receiveMsg(msg) //A应该要返回信息 &#125;&#125;;console.log(B.callA(\"Hello A!\")); 更复杂一些,B对A发出信息，假如A里面的没有信箱，那么用Tools构造函数 new一个信箱对象，其属性message存储发来的消息，把信箱对象作为对外APIreceiveMsg函数的返回值，返回给B对象。任由B处理此对象~ 123456789101112131415161718192021222324252627 //匿名函数自执行，return 1个对象赋给Avar A = (function()&#123; //准备作为API返回对象 var _msgBox; //将B发来的消息传进Tools构造函数 var _Tools = function(msg)&#123; this.message = msg; &#125;; return &#123; receiveMsg: function(msg)&#123; if(!_msgBox)&#123; _msgBox = new _Tools(msg); &#125; // 返回对象(对象可包含更多信息) return _msgBox; &#125; &#125;&#125;)(); //对象字面量直接定义var B = &#123; callA: function(msg)&#123; //A返回的msgBox赋值给cbMsg var cbMsg = A.receiveMsg(msg); alert(cbMsg.message); &#125;&#125;;B.callA(\"Hello A! Give me five~\"); 应用实例：","raw":null,"content":null,"categories":null,"tags":[{"name":"Js","slug":"Js","permalink":"https://holoncaro.github.io/tags/Js/"}]},{"title":"那些坑！种上花，埋上土","slug":null,"date":"2017-03-22T10:21:38.000Z","updated":null,"comments":null,"path":"2017/03/22/interview-questions/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"略坑的小题儿些… Js数组操作中，哪些方法不能改变自身？ join/concat/slice push =&gt; 改变，返回新长度。unshifi =&gt; 改变，返回新长度。pop =&gt; 改变，返回被删元素。shift =&gt; 改变，返回被删元素。join =&gt; 不变，返回字符串。reverse =&gt; 改变，返回翻转数组。sort =&gt; 改变，返回排序数组。concat =&gt; 不变，返回合并后数组。slice =&gt; 不变，返回切割的数组。splice =&gt; 改变，返回丢弃部分。 假设output是函数，输出一行文本。下面输出什么？12&gt; output(typeof( output(\"Hello World!\") );&gt; Hello World! undefined 内层函数输出Hello World！，没有return返回值，默认返回undefined，typeof undefined依旧为undefined。 12345678&gt; function Fn()&#123;&gt; this.do = function()&#123; return 'foo' &#125;&gt; &#125;;&gt; Fn.prototype = function()&#123;&gt; this.do = function()&#123; return 'bar' &#125;&gt; &#125;&gt; var x = new Fn().do();&gt; ‘foo’ new Fn()，实例化了一个对象，this指向这个对象，并且有do()方法，不沿着原型链往上找了。 RegExp对象的方法有什么？ compile/exec/test 1234567891011&gt; var A = &#123; n:4399 &#125;;&gt; var B = function()&#123; this.n=9999 &#125;;&gt; var C = function()&#123; var n=8888 &#125;;&gt; B.prototype = A;&gt; C.prototype = A; //B、C原型都是A&gt; var b = new B(); //b.n=9999!&gt; var c = new C(); //c自身没有n属性，找到prototype上的n属性&gt; A.n++;&gt; console.log(b.n);&gt; console.log(c.n); //4400&gt; 9999、4400 12345678&gt; var bb = 1;&gt; function fn(bb)&#123; //形参变量=局部变量&gt; bb = 2;&gt; alert(bb);&gt; &#125;&gt; fn(bb);&gt; alert(bb);&gt; 2、1 此题去掉形参，则弹出2、2。 var val; console.log(‘Value is’ + (val!=’0’) ? ‘define’:’undefine’); ‘+’优先级高于三目运算，低于括号。JS中，6中情况当成false =&gt; false/undefined/null/0/NAN/‘’ Javascript 异步模式的编程？ 回调函数、事件监听、发布/订阅、Promises对象 ‘+new Array(017)’输出结果是什么？ NAN 八进制的17 &lt;==&gt; ‘+new Array(15)’=&gt;Number(new Array(15))=&gt;Number(new Array(15).valueOf()) [不是原始值，执行toString()]=&gt;Number(new Array(15).toString())=&gt;Number(“,,,,,,,,,,,,,,”)=&gt;NAN 1234567891011&gt; var a = 'undefined';&gt; var b = 'false';&gt; var c = '';&gt; function assert(aVar)&#123;&gt; if(aVar) &#123; alert(true); &#125;&gt; else &#123; alert(false); &#125;&gt; &#125;&gt; assert(a);&gt; assert(b);&gt; assert(c);&gt; true/true/false 关于IE、FF脚本的区别描述正确的是？ innerText IE支持，FF不支持。setAttribute(‘class’,’styleClass’) FF支持，IE不支持 兼容性问题 浏览器端存储技术？ cookie =&gt; 大小限制在4k，放在请求头浪费带宽，过期前有效。sessionStorage =&gt; 5M，本地，关闭即删除。localStorage =&gt; 5M，本地，手动删除。","raw":null,"content":null,"categories":null,"tags":[{"name":"interview","slug":"interview","permalink":"https://holoncaro.github.io/tags/interview/"}]},{"title":"Gulp","slug":null,"date":"2017-03-19T11:51:12.000Z","updated":null,"comments":null,"path":"2017/03/19/Gulp/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Gulp：自动化构建工具，实质就是完成机械的重复的工作。实现LESS/SASS编译、压缩、合并，JS合并、压缩、混淆，img压缩复制，html压缩等。 npm init 回答一系列问题之后，生成package.json文件（包管理）。 npm install gulp --save-dev wait等着…生成node_modules的，里面有gulp包。同时package.json里加入开发包依赖。 gulp主文件 gulpfile.js(文件名固定)，用于注册任务。 123456//引入Gulp模块var gulp = require('gulp');//注册一个任务gulp.task('say', function()&#123; //执行say任务的代码&#125;) 原代码文件src / 发布文件dist(distribution) 转存文件gulp.src取文件，gulp.dest放置文件。 12gulp.src('src/index.html') .pipe(gulp.dest('dist/')); 监视任务 1gulp.watch('src/index.html',['copy']) 手动触发主任务，然后监视文件触发子任务 Gulp插件 Less编译，CSS压缩编译：npm install gulp-less --save-dev压缩：npm install gulp-cssnano --save-dev合并的话，可以用Less的@import导包方法，前下划线_demo.less不进管道 123456789var less = require('gulp-less');var cssnano = require('gulp-cssnano');//注册一个任务gulp.task('style', function()&#123; gulp.src('src/style/*.less') .pipe(less()) .pipe(cssnano()) .pipe(gulp.dest('dist/style'))&#125;) 此时可以在dist任务中，增加一个监视。 JS合并、压缩、混淆先合并，后混淆 1234567var concat = require('gulp-concat');gulp.task('script', function()&#123; gulp.src('src/scripts/*.js') .pipe(concat('all.js')) .pipe(uglify()) //压缩混淆均由uglify()处理 .pipe(gulp.dest('dist/scripts/'))&#125;) IMG复制 1234gulp.task('image', function()&#123; gulp.src('src/images/*.*') .pipe(gulp.dest('dist/images/'))&#125;) HTML复制 123456789var htmlmin = require('gulp-htmlmin');gulp.task('html', function()&#123; gulp.src('src/*.html') .pipe(htmlmin(&#123; collapseWhitespace: true, //删除空白分行 removeComments: true //删除注释 &#125;)) .pipe(gulp.dest('dist/'))&#125;) browser-sync同步各浏览器动作，进行差异测试npm install browser-sync --save-dev 12345678910var browserSync = require('browser-sync').create();gulp.task('serve', function()&#123; browserSync.init(&#123; server: &#123;baseDir:'./dist/'&#125; &#125;) gulp.watch('src/style/*.less', ['style']); gulp.watch('src/scripts/*.js', ['script']); ...&#125;) 实现更改文件后，浏览器自动刷新的具体代码见我的REPO：Github/project_gulp 常用插件[编译Less: gulp-less][创建本地服务器: browser-sync][合并文件: gulp-concat][最小化js文件: gulp-uglify][重命名文件: gulp-raname][最小化CSS文件: gulp-cssnano][压缩html文件: gulp-minify-html][最小化图像: gulp-imagemin]","raw":null,"content":null,"categories":null,"tags":[{"name":"gulp","slug":"gulp","permalink":"https://holoncaro.github.io/tags/gulp/"}]},{"title":"Function Execute(函数调用顺序解析)","slug":null,"date":"2017-03-18T16:05:58.000Z","updated":null,"comments":null,"path":"2017/03/19/Function Execute/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"变量定义提升、this指针、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等知识点 123456function Foo()&#123; getName = function()&#123; console.log(\"No.1\") &#125;; return this;&#125; 构造器函数小结： 函数执行一次，getName这个无var变量才挂载到window对象下。Foo(); getName(); =&gt; No.1 Foo()，返回的this指向window对象。Foo().getName(); =&gt; No.1 new Foo()，返回的this指向新建对象。new Foo().getName() =&gt; undefined 123Foo.getName = function()&#123; console.log(\"No.2\")&#125;; 创建Foo对象的静态属性getName，存储一个匿名函数： Foo.getName(); =&gt; No.2 对象层面的一个属性。 123Foo.prototype.getName = function()&#123; console.log(\"No.3\")&#125;; 构造器原型上的getName方法: new Foo().getName() =&gt; No.3 123var getName = function()&#123; console.log(\"No.4\")&#125;; 函数表达式赋值： 函数不提前，变量提前.var getName; getName = function(){ ** }; 123function getName()&#123; console.log(\"No.5\")&#125;; 函数申明： 函数体提前。 经典题目，根据各种定义的函数，得出输各值出顺序：12345678910111213141516171819202122function Foo()&#123; getName = function()&#123; console.log(\"No.1\") &#125;; return this;&#125; Foo.getName = function()&#123; console.log(\"No.2\")&#125;; Foo.prototype.getName = function()&#123; console.log(\"No.3\")&#125;; var getName = function()&#123; console.log(\"No.4\")&#125;; function getName()&#123; console.log(\"No.5\")&#125;; Foo.getName(); =&gt;No.2 getName(); =&gt;No.4 Foo().getName(); =&gt;No.1 getName(); =&gt;1 new Foo.getName(); =&gt;No.2 new Foo().getName(); =&gt;No.3 new new Foo().getName(); =&gt;No.3 JavaScript解析后，实际执行顺序如下分析：123456789function Foo()&#123; getName = function()&#123; console.log(\"No.1\") &#125;; return this;&#125;var getName; //变量声明提前function getName()&#123; console.log(\"No.5\") &#125;; //函数声明提前Foo.getName = function()&#123; console.log(\"No.2\") &#125;;Foo.prototype.getName = function()&#123; console.log(\"No.3\") &#125;;getName = function()&#123; console.log(\"No.4\") &#125;; Foo.getName();—Foo对象的getName属性，题目中如果没有function Foo(){ ** }，是无法定义Foo.getName = function(){ ** }，因为undefined不能有属性。 ==&gt; No.2 getName();—普通的函数调用，因为申明提前，同名函数后面覆盖前面的。 ==&gt; No.4 Foo().getName();—Foo()调用后，查找getName，Foo()函数里没有定义，爬到上层继续查找，找到console.log(&quot;No.4&quot;)，覆盖之！ ==&gt; No.1 getName();—已经被上个覆盖了,所以调用仍返回相同的。 ==&gt; No.1 new Foo.getName();—等同于new (Foo.getName())，仅仅是将其作为构造函数执行。 ==&gt; No.2 new Foo().getName();—new Foo()调用后，返回的是一个构造器创建的新对象，这类对象上都有prototype上继承来的属性和方法。 ==&gt; No.3 new new Foo().getName();—等同于new((new Foo()).getName)(),先执行(new Foo()).getName，为实例对象上的getName函数本身，再将函数本身作为构造函数new(function(){ ** })() ==&gt; No.3","raw":null,"content":null,"categories":null,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://holoncaro.github.io/tags/JavaScript/"}]},{"title":"JSON","slug":null,"date":"2017-03-15T11:31:47.000Z","updated":null,"comments":null,"path":"2017/03/15/JSON/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"JSON JavaScript Object Notation，JS对象表示法，其为数据结构，不是编程语言。针对JSON，有序列化器和解析器。 1.JSON可以表示三种类型值： 简单值(string 必须双引号, number, boolean, null, 无undefined) 对象 数组 12345&#123; \"name\": \"Holoncaro\", \"isMale\": true, \"age\": 28&#125; 对象和数组通常是JSON数据结构的最外层形式，JSON不支持变量、函数、对象实例。 2. 全局JSON对象，有两个对象方法 stringify() 和 parse() ，用于将对象序列化为JSON字符串及将JSON解析为原生JS值。 123456789var arr = &#123; name: 'Holoncaro', age: undefined, hobby: null, loveNum: 2, sayHi : function()&#123; return this.name; &#125;&#125; 将上面Js对象进行各种序列化： 直接序列化(undefined和function会被抛弃)1console.log(JSON.stringify(arr)) 输出的结果为 {&quot;name&quot;:&quot;Holoncaro&quot;,&quot;hobby&quot;:null,&quot;loveNum&quot;:2} 带过滤数组的序列化1console.log(JSON.stringify(arr,[\"name\"])) 输出的结果为 {&quot;name&quot;:&quot;Holoncaro&quot;} 带过滤函数的序列化123456789101112JSON.stringify(arr, function(key, value)&#123; switch(key)&#123; case \"name\": return 'Hi'+value; case \"age\": return 25; case \"loveNum\": return undefined; default: return value; &#125;&#125;) 输出的结果为 {&quot;name&quot;:&quot;HiHoloncaro&quot;,&quot;age&quot;:25,&quot;hobby&quot;:null} 3. ‘JSON.stingify()’第三个参数，使字符串保持缩进。 1console.log(JSON.stringify(obj,null,2)); 输出的结果为 { &quot;name&quot;: &quot;Holoncaro&quot;, &quot;isMale&quot;: true, &quot;age&quot;: 28 } 4. 如果对象里定义了toJSON()方法，则使用JSON.stringify()时，自动调用toJSON()。","raw":null,"content":null,"categories":null,"tags":[{"name":"JSON","slug":"JSON","permalink":"https://holoncaro.github.io/tags/JSON/"},{"name":"《Js高级程序设计》","slug":"《Js高级程序设计》","permalink":"https://holoncaro.github.io/tags/《Js高级程序设计》/"}]},{"title":"Hexo & Github Deploy Static Blog","slug":null,"date":"2017-03-14T15:45:17.000Z","updated":null,"comments":null,"path":"2017/03/14/Hexo & Github Deploy Static Blog/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"用Hexo和Github部署静态博客 前期准备 电脑装有NodeJs、Git，注册了Github账户。 Hexo：简单来说，就是一款快速生成博客框架的插件； Github： 代码托管、社交编程网站，顺便将Repo仓库里代码生成可视页面，须有index.html默认入口文件； NodeJs： 基于Chrome的V8引擎提取出的JavaScript语言的运行环境，这里主要运行npm； Git： 代码版本管理工具，这儿用于本地代码上传至github服务器保存。 博客雏形 在Git-bash中运行下面指令(配置好npm环境变量)，安装hexo这个node_module `npm install hexo-cli --global` 新建一个文件夹/folder，在其中打开Git-bash，运行命令，/folder文件夹中自动生成需要的框架： `hexo init ` 根据package.json，自动安装hexo运行所依赖的所有包，生成node_modules文件夹(时间稍长，此步建议翻墙): `npm install` 可以先在本地跑下博客雏形，在/folder中打开Git-bash，运行指令: `hexo generate` 生成public文件夹，即静态页面生成，然后运行下面指令，启动本地服务器(127.0.0.1:4000) `hexo server` 在Git-bash中Ctrl+C可以停止本地服务器 Github仓库 在Github中创建名为: YourName.github.io的repository，其中YourName为用户名。 开始部署 在/folder文件夹中Git-bash运行下面指令(–save为了将包信息保存在package.json中): `npm install hexo-deployer-git --save` 修改_config.yml文件中配置： deploy: type: git repository: https://github.com/YourName/YourName.github.io branch: master 再用Git-bash挨个输入下面指令 `hexo clean` 清除上次自动生成的静态博客 `hexo generate` 再次生成新的静态博客 `hexo deploy` 同步部署到github的YourName.github.io仓库 如果没有配置SSH的话，过程中应该要输入用户名和密码进行确认，不然随意同步别人的仓库岂不乱套了。 发表文章 输入下面指令，在/folder/source/_post中生成后缀为.md的轻标记类型文章: `hexo new &quot;Article Title&quot;` 新建页面，在/folder/source中多了文件夹，其中还有个index.md入口文件: `hexo new page &quot;页面名称&quot;` 写完博文需要与Github同步，这样访问YourName.github.io就可以访问了: `hexo clean` `hexo generate` `hexo deploy` 切换主题 …未完待续","raw":null,"content":null,"categories":null,"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://holoncaro.github.io/tags/Hexo/"}]},{"title":"MarkDown Tips","slug":null,"date":"2017-03-12T15:01:04.000Z","updated":null,"comments":null,"path":"2017/03/12/MarkDown Tips/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Markdown标记语言的基本语法 1. 一级标题二级标题三级标题四级标题五级标题六级标题2. 无序列表 无序列表 无序列表 有序列表 有序列表 有序列表 3. 这是代表引用 这是二级引用 这是三级引用 4.Github 5.我是粗体我是斜体 6.12var MarkDown = null;console.log(MarkDown); var Tabs = null;console.log(Tabs); 7.我是分割线 我是分割线","raw":null,"content":null,"categories":null,"tags":[{"name":"markdown","slug":"markdown","permalink":"https://holoncaro.github.io/tags/markdown/"}]}]