[{"title":"Waterfall","slug":null,"date":"2017-03-26T14:50:26.000Z","updated":null,"comments":null,"path":"2017/03/26/Waterfall/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"函数式实现瀑布流加载效果,在滚动到页面底部时,进行自动加载. HTML结构 12345678&lt;div id=\"main\" class=\"clearFix\"&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"pic\"&gt; &lt;img src=\"pic/1.JPG\" alt=\"img\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 类似.wrap结构 --&gt;&lt;/div&gt; CSS样式 123456789101112131415161718192021222324#main&#123; position: relative; width: 90%; margin: 0 auto;&#125;.wrap&#123; float: left; padding: 15px 0 0 15px;&#125;.pic&#123; padding: 10px; border: 1px solid #ccc; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.5);&#125;img&#123; width: 230px; height: auto;&#125;.clearFix:after&#123; content: ''; display: block; clear: both;&#125; JavaScript代码waterFall()函数,对如何插入进行解析? 12345678910111213141516171819202122232425262728293031323334function waterFall(parent,brick)&#123; // 获取到需要waterfall的对象 var oParent = document.getElementById(parent); // 获取到图片砖组成的数组,这里对IE低版本的重写了getByClass函数 var aBrick = oParent.getElementsByClassName ? oParent.getElementsByClassName(brick) : getByClass(parent,brick); // img宽度230px,由此获取单个brick的宽度 // 267,包括padding,无px值(15+10+10+2+230) var oBrickW = aBrick[0].offsetWidth; // 获取主屏可视区的宽度 var windowW = window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth; // 向下取整,每行最多显示的图片砖数 // 动态设置#mian的宽度,将其居中 var rowN = Math.floor(windowW/oBrickW); var mainW = rowN*oBrickW; oParent.style.cssText = \"width:\"+mainW+\"px; margin:0 auto;\"; // 如何插值,将新aBrick[i]插到最短的那一列. // arrH存储每一列的高度值. var arrH = []; for(var i=0,len=aBrick.length;i&lt;len;i++)&#123; if(i&lt;rowN)&#123; //第一排,按顺序插排,然后存储列高就行. arrH.push(aBrick[i].clientHeight); &#125;else&#123; // 用Math.min方法,获取数组中的最小值. var minH = Math.min.apply(null,arrH); // 自定义函数,获取最短列的index索引. var index = getIndex(arrH,minH); // 对新插进的,进行动态绝对定位. aBrick[i].style.cssText = \"position:absolute;top:\"+minH+\"px;left:\"+oBrickW*index+\"px\"; // 插入了新图砖,对此列高度进行增加. arrH[index] += aBrick[i].offsetHeight; &#125; &#125;&#125; insertPic()函数,触发事件时,新插入图片砖的数量123456789101112131415161718192021222324252627function insertPic(parent,count)&#123; var oParent = document.getElementById(parent); for(var i=0;i&lt;count;i++)&#123; // Test,随机获取图片路径 var random = Math.ceil(Math.random()*20); // 创建img对象,并对'alt'和'src'属性赋值. var oImg = document.createElement(\"img\"); /* oImg.alt = random; */ /* oImg.src = \"pic/\"+random+\".jpg\"; */ oImg.setAttribute(\"alt\",random); oImg.setAttribute(\"src\",\"pic/\"+random+\".jpg\"); // 创建div对象,并对其增加.pic属性 var oPic = document.createElement(\"div\"); /* oPic.setAttribute(\"class\",\"pic\"); */ /* oPic.setAttribute(\"className\",\"pic\"); //for IE */ oPic.className = \"pic\"; // 创建div对象,并对其增加.wrap属性 var oWrap = document.createElement(\"div\"); /* oWrap.setAttribute(\"class\",\"wrap\"); */ /* oWrap.setAttribute(\"className\",\"wrap\"); //for IE */ oWrap.className = \"wrap\"; // 确定3个对象的所属关系. oPic.appendChild(oImg); oWrap.appendChild(oPic); oParent.appendChild(oWrap); &#125;&#125; judgeInsert()函数,滚动监听的事件函数123456789101112function judgeInsert(parent,count)&#123; // 可视区的高度 var windowH = window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight; // 可视区高度+滚动消失的高度 var scrollH = document.documentElement.scrollHeight || document.body.scrollHeight; // 滚动消失的高度 var scrollT = document.documentElement.scrollTop || document.body.scrollTop; // 当离底部50px时候,加载插入函数insertPic. if(windowH+scrollT&gt;=(scrollH-50))&#123; insertPic(parent,count); &#125;&#125; 2个附属函数:(兼容IE,从className获取对象)1234567891011121314151617181920function getByClass(parent,classValue)&#123; var oParent = document.getElementById(parent); var allEle = oParent.getElementsByTagName('*'); var arr = []; for(var i=0,len=allEle.length;i&lt;len;i++)&#123; var classN = allEle[i].className; if(classN.indexOf(' ')==-1 &amp;&amp; classN==classValue)&#123; arr.push(allEle[i]); &#125;else if(classN.indexOf(' ')!=-1)&#123; var strArr = []; strArr = classN.split(' '); for(var j in strArr)&#123; if(strArr[j]==classValue)&#123; arr.push(allEle[i]); &#125; &#125; &#125; &#125; return arr;&#125; (获取列索引)1234567function getIndex(arr,val)&#123; for(var i in arr)&#123; if(arr[i]==val)&#123; return i; &#125; &#125;&#125; 控制函数12345678910window.onload = function()&#123; // 首先,对已有的图片砖进行规划,排列. waterFall(\"main\",\"wrap\"); // 滚动时,判断是否需要插入10条新数据? // 然后再执行规划,排序. window.onscroll = function()&#123; judgeInsert(\"main\",10); waterFall(\"main\",\"wrap\"); &#125;&#125; 如果html中置空了,没有图片砖. 那么先执行inserPic(&#39;main&#39;,30). 插入30条图片砖数据.","raw":null,"content":null,"categories":null,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://holoncaro.github.io/tags/JavaScript/"}]},{"title":"页面的经典布局模式","slug":null,"date":"2017-03-26T07:45:17.000Z","updated":null,"comments":null,"path":"2017/03/26/Layout/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"1列及多列的居中布局 1.. 一列居中布局12345678910.container&#123; width: 960px; height: 500px; /*333*/ margin: 0 auto; background-color: #900; /*字体美观,和布局无关*/ text-align: center; font: 30px/500px Arial; color: #fff;&#125; 2.. 两列布局HTML:1234&lt;div class=\"wrap clearFix\"&gt; &lt;div class=\"fl\"&gt;左浮动&lt;/div&gt; &lt;div class=\"fr\"&gt;右浮动&lt;/div&gt;&lt;/div&gt; CSS:1234567891011121314151617181920212223242526.wrap&#123; width: 960px; margin: 0 auto; border: 2px solid #ff4500; /*字体美观,和布局无关*/ text-align: center; font: 30px/500px Arial; color: #fff;&#125;.fl&#123; float: left; width: 280px; height: 500px; background-color: #900;&#125;.fr&#123; float: right; width: 660px; height: 500px; background-color: #b22;&#125;.clearFix:after&#123; content: ''; display: block; clear: both;&#125; 3..三列布局(左右浮动)HTML:1234567&lt;div class=\"wrap clearFix\"&gt; &lt;div class=\"fl\"&gt;左浮动&lt;/div&gt; &lt;div class=\"fr\"&gt;右浮动&lt;/div&gt; &lt;div class=\"middle\"&gt; RequireJS ... of scripts: &lt;/div&gt;&lt;/div&gt; CSS:1234567891011121314151617181920212223242526272829.wrap&#123; width: 90%; margin: 0 auto; text-align: center; font: 20px/40px Arial; color: #fff;&#125;.fl&#123; float: left; width: 250px; height: 500px; background-color: #900;&#125;.fr&#123; float: right; width: 160px; height: 500px; background-color: #69c;&#125;.middle&#123; margin: 0 160px 0 250px; height: 500px; background-color: #eee;&#125;.clearFix:after&#123; content:''; display:block; clear:both;&#125; 三列布局(绝对定位,中间部分随着页面可缩小)HTML:1234567&lt;div class=\"wrap clearFix\"&gt; &lt;div class=\"pl\"&gt;左绝对定位&lt;/div&gt; &lt;div class=\"middle\"&gt; RequireJS ... of scripts: &lt;/div&gt; &lt;div class=\"pr\"&gt;右绝对定位&lt;/div&gt;&lt;/div&gt; CSS:12345678910111213141516171819202122232425262728293031.wrap&#123; position: relative; min-width:600px; margin: 0 auto;&#125;.pl&#123; position: absolute; left: 0; top: 0; width: 200px; height: 500px; background-color: #900;&#125;.pr&#123; position: absolute; right: 0; top: 0; width: 180px; height: 500px; background-color: #69c;&#125;.middle&#123; margin: 0 180px 0 200px; height: 500px; background-color: #eee;&#125;.clearFix:after&#123; content: ''; display: block; clear: both;&#125;","raw":null,"content":null,"categories":null,"tags":[{"name":"HTML","slug":"HTML","permalink":"https://holoncaro.github.io/tags/HTML/"}]},{"title":"用RequireJs模块化Js","slug":null,"date":"2017-03-26T03:47:41.000Z","updated":null,"comments":null,"path":"2017/03/26/RequireJs/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"RequireJs: require模块思想源于NodeJs,用在前端将JavaScript代码也模块化. 之前用RequireJs遇到坑了! define中定义的模块直接返回函数时,后require中用module()调用.注意! paths配置中,文件名和moduleID名同名,require引用时,文件名覆盖moduleID. Js合理的目录结构: __js |__app //自定义的模块 | |__module.js |__lib //第三方模块 | |__jquery.js | |__require.js |__main.js __index.html index.html引入requiredata-main指定主模块,首先被require加载,require默认文件名后缀.js,所以main可省略.js&lt;script data-main=&quot;js/main&quot; src=&quot;js/lib/require.js&quot;&gt;&lt;/script&gt;(相对于index.html的路径~) main.js配置12345678910111213141516171819require.config(&#123; //可以不配置baseUrl,因为main.js与之同根目录 baseUrl: 'js', paths: &#123; //以js/为根寻找文件,不能加.js后缀 req: \"lib/require\", jquery: \"lib/jquery-1.11.3\", //不能为(module:\"app/module\")! //因为后面的module为路径名,而不为moduleID. mod: \"app/module\" &#125;&#125;);require(['jquery','req','mod'], function($,req,mod)&#123; $(function()&#123; console.log('jquery加载成功~~.'); mod.fn(); &#125;);&#125;) 自定义模块module.js return的是对象,则调用形式为mod.fn(); return的是函数,则调用形式为mod();12345678define([],function()&#123; var fn = function()&#123; console.log('module引入成功'); &#125; return&#123; fn: fn &#125;;&#125;)","raw":null,"content":null,"categories":null,"tags":[{"name":"RequireJs","slug":"RequireJs","permalink":"https://holoncaro.github.io/tags/RequireJs/"}]},{"title":"如果判断Js中的各种数据类型","slug":null,"date":"2017-03-25T05:10:56.000Z","updated":null,"comments":null,"path":"2017/03/25/Data-Type/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"总的来说，typeof对Object区分不清，instanceof只是针对Object。怎么完美判断数据类型??(基本类型String/Number/Boolean引用类型Array/Function/Object) typeof 对各数据类型的判断：123456789typeof 'hong' ; // =&gt;stringtypeof 1022 ; // =&gt;numbertypeof true ; // =&gt;booleantypeof null ; // =&gt;object*typeof undefined ; // =&gt;undefinedtypeof [1,2] ; // =&gt;object*typeof function()&#123; &#125; ; // =&gt;functiontypeof &#123;name:'hong'&#125; ; // =&gt;object*typeof 23/'h' ; // =&gt;Nan 如上，对null/数组/纯对象均返回object，typeof不能有效区分三者类型。 instanceof 对各数据的判断：123456789'hong' instanceof String; // =&gt;false1022 instanceof Number; // =&gt;falsetrue instanceof Boolean; // =&gt;falsenull instanceof Object; // =&gt;falseundefined instanceof Object; // =&gt;false[1,2] instanceof Array; // =&gt;truefunction()&#123;&#125; instanceof Function; // =&gt;true&#123;name:'hong'&#125; instanceof Object; // =&gt;true23/'h' instanceof Object; // =&gt;false 但是如果验证:var str = new String(&#39;Hong&#39;);str instanceof String;则会返回true!instanceof用于进一步区分object类型。 用Object原型上的toString()方法，判断数据类型：1234567(function(global)&#123; function dataType(data)&#123; var _toString = Object.prototype.toString; return _toString.call(data).slice(8,-1); &#125; global.dataType = dataType;&#125;)(window); 使用此方法进行验证判断，结果如下：123456789getType('Holoncaro'); //--&gt;StringgetType(2017); //--&gt;NumbergetType(true); //--&gt;BooleangetType(null); //--&gt;Null(IE7及以下为Object)getType(undefined); //--&gt;Undefined(IE7及以下为Object)getType(['a','b']); //--&gt;ArraygetType(function()&#123;&#125;); //--&gt;FunctiongetType(&#123;name:'hong'&#125;); //--&gt;ObjectgetType(23/'h'); //--&gt;Number ***NaN类型需要单独区分*** 对’3.’方法进行再完善：12345678910111213141516171819202122232425262728(function(global)&#123; function dataType(data)&#123; var _toString = Object.prototype.toString; var _type = _toString.call(data).slice(8,-1); switch(_type)&#123; //IE7及其以下,会把null/undefined当做Object。 //需要对_type='Object'进行过滤 case 'Object': if(obj===null)&#123; return 'Null'; &#125;else if(obj===undefined)&#123; return 'Undefined'; &#125;else&#123; return 'Object'; &#125; //所有浏览器对NaN返回'Number'，进行NaN过滤。 case 'Number': if(obj!==obj)&#123; return 'NaN'; &#125;else&#123; return 'Number'; &#125; default: return _type; &#125; &#125; global.dataType = dataType;&#125;)(window);","raw":null,"content":null,"categories":null,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://holoncaro.github.io/tags/JavaScript/"}]},{"title":"ES3语法重构ES5的数组方法","slug":null,"date":"2017-03-24T15:57:33.000Z","updated":null,"comments":null,"path":"2017/03/24/Reconstruction/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"IE8及其更低版本的IE浏览器，不支持ES5的数组新方法，在此用自己的想法重构这些方法，使之有更广泛的兼容性。 小结： 原数组不改变，一般原型方法里建空数组，最后return出来。 原数组改变，一般用this[index]，改变原数组的每个value。 filter()方法，对元素过滤，返回满足回调函数条件的value。arr.filter(function(item,index){ //需要过滤下的value，返回true。 return *;}) 1234567891011121314151617181920(function()&#123; if(Array.prototype.filter)&#123; //原生支持，则用原生方法。 return null; &#125;else&#123; //数组原型上无此方法，则进行添加。 //filter方法接收回调函数。 Array.prototype.filter = function(cb)&#123; var _result = []; var len = this.length; for(var i=0; i&lt;len; i++)&#123; //将value和key传进cb中，进行验收。 if(cb(this[i], i))&#123; _result.push(this[i]) &#125; &#125; return _result; &#125; &#125;&#125;)(); 使用实例：12345678(function()&#123; var arr = [1,2,3,4,5,6,7,8,9,10] var _return = arr.filter(function(item, index)&#123; return index%3==0 || item&gt;8; &#125;); console.log(arr); //--&gt;原数组不变!!! console.log(_return); //--&gt;[1,4,7,9,10]&#125;)(); forEach()方法，对每个value进行同样的操作。arr.forEach(function(item, index, self){ //对item的操作不会影响原数组(并不是传的指针地址) //如不用self，需要自己创建新数组存储 //调用self，改变原数组}) 123456789101112(function()&#123; if(Array.prototype.forEach)&#123; return null; &#125;else&#123; Array.prototype.forEach = function(cb)&#123; var len = this.length; for(var i=0; i&lt;len; i++)&#123; cb(this[i], i, this) &#125; &#125; &#125;&#125;)(); 使用实例：1234567891011121314//不用self，新建数组var arr = [1,2,3,4,5];var result = [];arr.forEach(function(item)&#123; result.push(item+2);&#125;)console.log(result); //=&gt;[3,4,5,6,7]//调用self改变原数组arr = [1,2,3,4,5];arr.forEach(function(item,index,self)&#123; self[index] += 2;&#125;)console.log(arr); //=&gt;[3,4,5,6,7] map()方法，对整个数组进行一个映射。arr.map(function(item){ //将回调函数的新值return出去，map()方法将return的值添加进空数组。 //最后由map()方法return出去，不改变原数组}) 123456789101112131415(function()&#123; if(Array.prototype.map)&#123; return null; &#125;else&#123; Array.prototype.map = function(cb)&#123; var _result = []; var len = this.length; for(var i=0; i&lt;len; i++)&#123; //_result需要添加cb()方法return出的元素 _result.push( cb(this[i]) ); &#125; return _result; &#125; &#125;&#125;)(); 使用实例：12345678(function()&#123; var arr = [1,2,3,4]; var _return = arr.map(function(item)&#123; return item+10; &#125;) console.log(arr); //=&gt;[1,2,3,4] 原数组未改变!!! console.log(_return); //=&gt;[11,12,13,14]&#125;)();","raw":null,"content":null,"categories":null,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://holoncaro.github.io/tags/JavaScript/"}]},{"title":"Js函数中this关键字的指向","slug":null,"date":"2017-03-23T10:39:18.000Z","updated":null,"comments":null,"path":"2017/03/23/this-Keyword/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"JavaScript中关键字this的各种指向问题浅析 Js的this必须在函数中，函数定义时并不确定this指向，必须看函数谁调用??。函数调用：直接调用/方法调用/new调用/特殊调用(call.apply，函数绑定到对象上进行调用) 直接调用任何作用域下，直接通过fn()来进行调用的方式，均为直接调用。比如：123456!function fn0()&#123; function fn1()&#123; console.log(this) =&gt; window对象 &#125;; fn1();&#125;() 方法调用通过对象调用其方法，obj.method()调用形式，this指向调用该方法的对象：12345678910var name = '外层空间';var obj = &#123; name : 'Holoncaro', sayName : function()&#123; console.log(this.name); &#125;&#125;obj.sayName(); =&gt; Holoncarofn = obj.sayName;fn(); =&gt; 外层空间，this指谁调用! new调用通过new构造函数产生新对象（注意是否有return）:12345function Person(name)&#123; this.name = name;&#125;;var person = new Person('Holoncaro');console.log(person.name); =&gt; Holoncaro 如果构造函数里面有return，那么问题来了： return null/undefined/基本数据类型，等同于可以忽略。 return {}/[]等对象类型，person就指向return的对象。 new Construct()是一种创建对象的语法糖，等价于：123456789&gt; var bar = (function(name)&#123;&gt; var _newObj = &#123;&gt; constructor : person,&gt; __proto__ : person.prototype&gt; &#125;;&gt; _newObj.constructor(name);&gt; return _newObj;_&gt; &#125;)();&gt; call/apply调用通过将函数和对象绑定，改变执行上下文。并且可用此调用深入理解直接调用和方法调用: 直接调用 fn() &lt;==&gt; fn.call(window)方法调用 obj.method() &lt;==&gt; obj.method.call(obj)","raw":null,"content":null,"categories":null,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://holoncaro.github.io/tags/JavaScript/"}]},{"title":"设计模式","slug":null,"date":"2017-03-22T13:18:03.000Z","updated":null,"comments":null,"path":"2017/03/22/Design-pattern/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"设计模式是一套被反复使用、思想成熟、经过分类和无数实战设计经验总结的。为了让系统代码可重用、可扩展、可解耦。设计模式使代码开发真正工程化。 设计原则 [开闭原则] 对扩展开放，对修改关闭。(试卷附加题)[里氏转换原则] 子类继承父类，单独可运行。(盗版光盘)[依赖倒转原则] 引用一个对象，如果对象有底层类型，直接引用底层。(打井水)[接口隔离原则] 每一个接口为一种角色。(USB插头)[合成/聚合复用原则] 新对象应使用已有对象，使之成为新对象的一部分。(旧零件组装新物品)[迪米特原则] 一个对象应对其他对象有尽可能少的了解。(只对自己对象深入了解) 单例模式 单例模式：保证一个类只有一个实例，先判断实例是否存在，存在则直接返回，如果不存在就创建后再返回。 两个对象间的通信(B对A发出一个不为空的消息，A返回”Thank you B!”消息) 1234567891011121314151617var A = (function()&#123; //匿名函数自执行，return 1个对象 return &#123; receiveMsg: function(msg)&#123; if(msg)&#123; return \"Thank you B!\"; &#125; &#125; &#125;&#125;)();var B = &#123; //对象字面量直接定义 callA: function(msg)&#123; return A.receiveMsg(msg) //A应该要返回信息 &#125;&#125;;console.log(B.callA(\"Hello A!\")); 更复杂一些,B对A发出信息，假如A里面的没有信箱，那么用Tools构造函数 new一个信箱对象，其属性message存储发来的消息，把信箱对象作为对外APIreceiveMsg函数的返回值，返回给B对象。任由B处理此对象~ 123456789101112131415161718192021222324252627 //匿名函数自执行，return 1个对象赋给Avar A = (function()&#123; //准备作为API返回对象 var _msgBox; //将B发来的消息传进Tools构造函数 var _Tools = function(msg)&#123; this.message = msg; &#125;; return &#123; receiveMsg: function(msg)&#123; if(!_msgBox)&#123; _msgBox = new _Tools(msg); &#125; // 返回对象(对象可包含更多信息) return _msgBox; &#125; &#125;&#125;)(); //对象字面量直接定义var B = &#123; callA: function(msg)&#123; //A返回的msgBox赋值给cbMsg var cbMsg = A.receiveMsg(msg); alert(cbMsg.message); &#125;&#125;;B.callA(\"Hello A! Give me five~\"); 应用实例(test)：123456&lt;body&gt; &lt;input type=\"button\" id=\"a\" value=\"btn_a\"/&gt; &lt;input type=\"button\" id=\"b\" value=\"btn_b\"/&gt; &lt;input type=\"button\" id=\"c\" value=\"btn_c\"/&gt; &lt;input type=\"button\" id=\"d\" value=\"btn_d\"/&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829var top = &#123; init : function(index, fn)&#123; this.render(index); this.bind(fn); &#125;, render : function(index)&#123; var me = this; me.btn_a = $('#'+index); &#125;, bind:function(fn)&#123; var me = this; me.btn_a.click(function()&#123; me.fn = fn; //做什么事 me.fn(); &#125;) &#125;&#125;;//给btn_a绑定点击事件top.init('a',function()&#123; alert(1);&#125;)//给btn_b绑定点击事件top.init('b',function()&#123; alert('I\\'m b');&#125;)...还可继续绑定 构造函数模式 构造函数用于创建特定类型的对象，可以接受参数以便初始化成员值。 1234567891011121314function Person()&#123; //即使没有new构造函数，也能正常执行，代码健壮！ if(!(this instanceof Person))&#123; return new Person(); &#125;; this.name = 'Holoncaro', this.sex = 'male', this.speak = function()&#123; return this.name+' is '+this.sex &#125;&#125;//此处没有new，因为有上面判断的代码，也能正常执行。var Hong = Person(); console.log(Hong.speak()); 建造者模式 将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。建造者模式：用于”分步构建一个复杂的对象”。各司其职，拆解流程。 1234567891011121314151617181920212223242526272829303132333435363738394041//一类房屋的建造规范function House()&#123; this.livingRoom = ''; this.bedRoom = ''; this.bathRoom = '';&#125;;//总工这一类人，负责指挥，有此能力function Guider(somebody)&#123; this.ability_build = function(somebody)&#123; somebody.build_livingroom(); somebody.build_bedroom(); somebody.build_bathroom(); &#125;;&#125;;//建造者这类人，需要的技能方法function Worker()&#123; this.build_livingroom = function()&#123; console.log('客厅建好了，有25平米.'); &#125;; this.build_bedroom = function()&#123; console.log('卧室建好了，有16平米带飘窗.'); &#125;; this.build_bathroom = function()&#123; console.log('卫生间建好了，有9平米.'); &#125;; this.finish = function()&#123; var _house = new House(); _house.livingRoom = 'ok'; _house.bedRoom = 'ok'; _house.bathRoom = 'ok'; return _house; &#125;&#125;;//招聘了一批建造者来工作，实例化对象，他们都有上面的能力。var worker = new Worker();//招聘一个总工，实例化对象，有指挥分工的能力。var guider = new Guider();guider.ability_build(worker); //发挥指挥的作用//对房屋进行验收，并打印。var check = worker.finish();console.log(check);","raw":null,"content":null,"categories":null,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://holoncaro.github.io/tags/JavaScript/"}]},{"title":"那些坑！种上花，埋上土","slug":null,"date":"2017-03-22T10:21:38.000Z","updated":null,"comments":null,"path":"2017/03/22/interview-questions/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"略坑的小题儿些… Js数组操作中，哪些方法不能改变自身？ join/concat/slice push =&gt; 改变，返回新长度。unshifi =&gt; 改变，返回新长度。pop =&gt; 改变，返回被删元素。shift =&gt; 改变，返回被删元素。join =&gt; 不变，返回字符串。reverse =&gt; 改变，返回翻转数组。sort =&gt; 改变，返回排序数组。concat =&gt; 不变，返回合并后数组。slice =&gt; 不变，返回切割的数组。splice =&gt; 改变，返回丢弃部分。 假设output是函数，输出一行文本。下面输出什么？12&gt; output(typeof( output(\"Hello World!\") );&gt; Hello World! undefined 内层函数输出Hello World！，没有return返回值，默认返回undefined，typeof undefined依旧为undefined。 12345678&gt; function Fn()&#123;&gt; this.do = function()&#123; return 'foo' &#125;&gt; &#125;;&gt; Fn.prototype = function()&#123;&gt; this.do = function()&#123; return 'bar' &#125;&gt; &#125;&gt; var x = new Fn().do();&gt; ‘foo’ new Fn()，实例化了一个对象，this指向这个对象，并且有do()方法，不沿着原型链往上找了。 RegExp对象的方法有什么？ compile/exec/test 1234567891011&gt; var A = &#123; n:4399 &#125;;&gt; var B = function()&#123; this.n=9999 &#125;;&gt; var C = function()&#123; var n=8888 &#125;;&gt; B.prototype = A;&gt; C.prototype = A; //B、C原型都是A&gt; var b = new B(); //b.n=9999!&gt; var c = new C(); //c自身没有n属性，找到prototype上的n属性&gt; A.n++;&gt; console.log(b.n);&gt; console.log(c.n); //4400&gt; 9999、4400 12345678&gt; var bb = 1;&gt; function fn(bb)&#123; //形参变量=局部变量&gt; bb = 2;&gt; alert(bb);&gt; &#125;&gt; fn(bb);&gt; alert(bb);&gt; 2、1 此题去掉形参，则弹出2、2。 var val; console.log(‘Value is’ + (val!=’0’) ? ‘define’:’undefine’); ‘+’优先级高于三目运算，低于括号。JS中，6中情况当成false =&gt; false/undefined/null/0/NAN/‘’ Javascript 异步模式的编程？ 回调函数、事件监听、发布/订阅、Promises对象 ‘+new Array(017)’输出结果是什么？ NAN 八进制的17 &lt;==&gt; ‘+new Array(15)’=&gt;Number(new Array(15))=&gt;Number(new Array(15).valueOf()) [不是原始值，执行toString()]=&gt;Number(new Array(15).toString())=&gt;Number(“,,,,,,,,,,,,,,”)=&gt;NAN 1234567891011&gt; var a = 'undefined';&gt; var b = 'false';&gt; var c = '';&gt; function assert(aVar)&#123;&gt; if(aVar) &#123; alert(true); &#125;&gt; else &#123; alert(false); &#125;&gt; &#125;&gt; assert(a);&gt; assert(b);&gt; assert(c);&gt; true/true/false 关于IE、FF脚本的区别描述正确的是？ innerText IE支持，FF不支持。setAttribute(‘class’,’styleClass’) FF支持，IE不支持 兼容性问题 浏览器端存储技术？ cookie =&gt; 大小限制在4k，放在请求头浪费带宽，过期前有效。sessionStorage =&gt; 5M，本地，关闭即删除。localStorage =&gt; 5M，本地，手动删除。","raw":null,"content":null,"categories":null,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://holoncaro.github.io/tags/JavaScript/"}]},{"title":"Gulp","slug":null,"date":"2017-03-19T11:51:12.000Z","updated":null,"comments":null,"path":"2017/03/19/Gulp/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Gulp：自动化构建工具，实质就是完成机械的重复的工作。实现LESS/SASS编译、压缩、合并，JS合并、压缩、混淆，img压缩复制，html压缩等。 npm init 回答一系列问题之后，生成package.json文件（包管理）。 npm install gulp --save-dev wait等着…生成node_modules的，里面有gulp包。同时package.json里加入开发包依赖。 gulp主文件 gulpfile.js(文件名固定)，用于注册任务。 123456//引入Gulp模块var gulp = require('gulp');//注册一个任务gulp.task('say', function()&#123; //执行say任务的代码&#125;) 原代码文件src / 发布文件dist(distribution) 转存文件gulp.src取文件，gulp.dest放置文件。 12gulp.src('src/index.html') .pipe(gulp.dest('dist/')); 监视任务 1gulp.watch('src/index.html',['copy']) 手动触发主任务，然后监视文件触发子任务 Gulp插件 Less编译，CSS压缩编译：npm install gulp-less --save-dev压缩：npm install gulp-cssnano --save-dev合并的话，可以用Less的@import导包方法，前下划线_demo.less不进管道 123456789var less = require('gulp-less');var cssnano = require('gulp-cssnano');//注册一个任务gulp.task('style', function()&#123; gulp.src('src/style/*.less') .pipe(less()) .pipe(cssnano()) .pipe(gulp.dest('dist/style'))&#125;) 此时可以在dist任务中，增加一个监视。 JS合并、压缩、混淆先合并，后混淆 1234567var concat = require('gulp-concat');gulp.task('script', function()&#123; gulp.src('src/scripts/*.js') .pipe(concat('all.js')) .pipe(uglify()) //压缩混淆均由uglify()处理 .pipe(gulp.dest('dist/scripts/'))&#125;) IMG复制 1234gulp.task('image', function()&#123; gulp.src('src/images/*.*') .pipe(gulp.dest('dist/images/'))&#125;) HTML复制 123456789var htmlmin = require('gulp-htmlmin');gulp.task('html', function()&#123; gulp.src('src/*.html') .pipe(htmlmin(&#123; collapseWhitespace: true, //删除空白分行 removeComments: true //删除注释 &#125;)) .pipe(gulp.dest('dist/'))&#125;) browser-sync同步各浏览器动作，进行差异测试npm install browser-sync --save-dev 12345678910var browserSync = require('browser-sync').create();gulp.task('serve', function()&#123; browserSync.init(&#123; server: &#123;baseDir:'./dist/'&#125; &#125;) gulp.watch('src/style/*.less', ['style']); gulp.watch('src/scripts/*.js', ['script']); ...&#125;) 实现更改文件后，浏览器自动刷新的具体代码见我的REPO：Github/project_gulp 常用插件[编译Less: gulp-less][创建本地服务器: browser-sync][合并文件: gulp-concat][最小化js文件: gulp-uglify][重命名文件: gulp-raname][最小化CSS文件: gulp-cssnano][压缩html文件: gulp-minify-html][最小化图像: gulp-imagemin]","raw":null,"content":null,"categories":null,"tags":[{"name":"gulp","slug":"gulp","permalink":"https://holoncaro.github.io/tags/gulp/"}]},{"title":"Function Execute(函数调用顺序解析)","slug":null,"date":"2017-03-18T16:05:58.000Z","updated":null,"comments":null,"path":"2017/03/19/Function Execute/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"变量定义提升、this指针、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等知识点 123456function Foo()&#123; getName = function()&#123; console.log(\"No.1\") &#125;; return this;&#125; 构造器函数小结： 函数执行一次，getName这个无var变量才挂载到window对象下。Foo(); getName(); =&gt; No.1 Foo()，返回的this指向window对象。Foo().getName(); =&gt; No.1 new Foo()，返回的this指向新建对象。new Foo().getName() =&gt; undefined 123Foo.getName = function()&#123; console.log(\"No.2\")&#125;; 创建Foo对象的静态属性getName，存储一个匿名函数： Foo.getName(); =&gt; No.2 对象层面的一个属性。 123Foo.prototype.getName = function()&#123; console.log(\"No.3\")&#125;; 构造器原型上的getName方法: new Foo().getName() =&gt; No.3 123var getName = function()&#123; console.log(\"No.4\")&#125;; 函数表达式赋值： 函数不提前，变量提前.var getName; getName = function(){ ** }; 123function getName()&#123; console.log(\"No.5\")&#125;; 函数申明： 函数体提前。 经典题目，根据各种定义的函数，得出输各值出顺序：12345678910111213141516171819202122function Foo()&#123; getName = function()&#123; console.log(\"No.1\") &#125;; return this;&#125; Foo.getName = function()&#123; console.log(\"No.2\")&#125;; Foo.prototype.getName = function()&#123; console.log(\"No.3\")&#125;; var getName = function()&#123; console.log(\"No.4\")&#125;; function getName()&#123; console.log(\"No.5\")&#125;; Foo.getName(); =&gt;No.2 getName(); =&gt;No.4 Foo().getName(); =&gt;No.1 getName(); =&gt;1 new Foo.getName(); =&gt;No.2 new Foo().getName(); =&gt;No.3 new new Foo().getName(); =&gt;No.3 JavaScript解析后，实际执行顺序如下分析：123456789function Foo()&#123; getName = function()&#123; console.log(\"No.1\") &#125;; return this;&#125;var getName; //变量声明提前function getName()&#123; console.log(\"No.5\") &#125;; //函数声明提前Foo.getName = function()&#123; console.log(\"No.2\") &#125;;Foo.prototype.getName = function()&#123; console.log(\"No.3\") &#125;;getName = function()&#123; console.log(\"No.4\") &#125;; Foo.getName();—Foo对象的getName属性，题目中如果没有function Foo(){ ** }，是无法定义Foo.getName = function(){ ** }，因为undefined不能有属性。 ==&gt; No.2 getName();—普通的函数调用，因为申明提前，同名函数后面覆盖前面的。 ==&gt; No.4 Foo().getName();—Foo()调用后，查找getName，Foo()函数里没有定义，爬到上层继续查找，找到console.log(&quot;No.4&quot;)，覆盖之！ ==&gt; No.1 getName();—已经被上个覆盖了,所以调用仍返回相同的。 ==&gt; No.1 new Foo.getName();—等同于new (Foo.getName())，仅仅是将其作为构造函数执行。 ==&gt; No.2 new Foo().getName();—new Foo()调用后，返回的是一个构造器创建的新对象，这类对象上都有prototype上继承来的属性和方法。 ==&gt; No.3 new new Foo().getName();—等同于new((new Foo()).getName)(),先执行(new Foo()).getName，为实例对象上的getName函数本身，再将函数本身作为构造函数new(function(){ ** })() ==&gt; No.3","raw":null,"content":null,"categories":null,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://holoncaro.github.io/tags/JavaScript/"}]},{"title":"JSON","slug":null,"date":"2017-03-15T11:31:47.000Z","updated":null,"comments":null,"path":"2017/03/15/JSON/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"JSON JavaScript Object Notation，JS对象表示法，其为数据结构，不是编程语言。针对JSON，有序列化器和解析器。 1.JSON可以表示三种类型值： 简单值(string 必须双引号, number, boolean, null, 无undefined) 对象 数组 12345&#123; \"name\": \"Holoncaro\", \"isMale\": true, \"age\": 28&#125; 对象和数组通常是JSON数据结构的最外层形式，JSON不支持变量、函数、对象实例。 2. 全局JSON对象，有两个对象方法 stringify() 和 parse() ，用于将对象序列化为JSON字符串及将JSON解析为原生JS值。 123456789var arr = &#123; name: 'Holoncaro', age: undefined, hobby: null, loveNum: 2, sayHi : function()&#123; return this.name; &#125;&#125; 将上面Js对象进行各种序列化： 直接序列化(undefined和function会被抛弃)1console.log(JSON.stringify(arr)) 输出的结果为 {&quot;name&quot;:&quot;Holoncaro&quot;,&quot;hobby&quot;:null,&quot;loveNum&quot;:2} 带过滤数组的序列化1console.log(JSON.stringify(arr,[\"name\"])) 输出的结果为 {&quot;name&quot;:&quot;Holoncaro&quot;} 带过滤函数的序列化123456789101112JSON.stringify(arr, function(key, value)&#123; switch(key)&#123; case \"name\": return 'Hi'+value; case \"age\": return 25; case \"loveNum\": return undefined; default: return value; &#125;&#125;) 输出的结果为 {&quot;name&quot;:&quot;HiHoloncaro&quot;,&quot;age&quot;:25,&quot;hobby&quot;:null} 3. ‘JSON.stingify()’第三个参数，使字符串保持缩进。 1console.log(JSON.stringify(obj,null,2)); 输出的结果为 { &quot;name&quot;: &quot;Holoncaro&quot;, &quot;isMale&quot;: true, &quot;age&quot;: 28 } 4. 如果对象里定义了toJSON()方法，则使用JSON.stringify()时，自动调用toJSON()。","raw":null,"content":null,"categories":null,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://holoncaro.github.io/tags/JavaScript/"},{"name":"《Js高级程序设计》","slug":"《Js高级程序设计》","permalink":"https://holoncaro.github.io/tags/《Js高级程序设计》/"}]},{"title":"Hexo & Github Deploy Static Blog","slug":null,"date":"2017-03-14T15:45:17.000Z","updated":null,"comments":null,"path":"2017/03/14/Hexo & Github Deploy Static Blog/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"用Hexo和Github部署静态博客 前期准备 电脑装有NodeJs、Git，注册了Github账户。 Hexo：简单来说，就是一款快速生成博客框架的插件； Github： 代码托管、社交编程网站，顺便将Repo仓库里代码生成可视页面，须有index.html默认入口文件； NodeJs： 基于Chrome的V8引擎提取出的JavaScript语言的运行环境，这里主要运行npm； Git： 代码版本管理工具，这儿用于本地代码上传至github服务器保存。 博客雏形 在Git-bash中运行下面指令(配置好npm环境变量)，安装hexo这个node_module `npm install hexo-cli --global` 新建一个文件夹/folder，在其中打开Git-bash，运行命令，/folder文件夹中自动生成需要的框架： `hexo init ` 根据package.json，自动安装hexo运行所依赖的所有包，生成node_modules文件夹(时间稍长，此步建议翻墙): `npm install` 可以先在本地跑下博客雏形，在/folder中打开Git-bash，运行指令: `hexo generate` 生成public文件夹，即静态页面生成，然后运行下面指令，启动本地服务器(127.0.0.1:4000) `hexo server` 在Git-bash中Ctrl+C可以停止本地服务器 Github仓库 在Github中创建名为: YourName.github.io的repository，其中YourName为用户名。 开始部署 在/folder文件夹中Git-bash运行下面指令(–save为了将包信息保存在package.json中): `npm install hexo-deployer-git --save` 修改_config.yml文件中配置： deploy: type: git repository: https://github.com/YourName/YourName.github.io branch: master 再用Git-bash挨个输入下面指令 `hexo clean` 清除上次自动生成的静态博客 `hexo generate` 再次生成新的静态博客 `hexo deploy` 同步部署到github的YourName.github.io仓库 如果没有配置SSH的话，过程中应该要输入用户名和密码进行确认，不然随意同步别人的仓库岂不乱套了。 发表文章 输入下面指令，在/folder/source/_post中生成后缀为.md的轻标记类型文章: `hexo new &quot;Article Title&quot;` 新建页面，在/folder/source中多了文件夹，其中还有个index.md入口文件: `hexo new page &quot;页面名称&quot;` 写完博文需要与Github同步，这样访问YourName.github.io就可以访问了: `hexo clean` `hexo generate` `hexo deploy` 切换主题 …未完待续","raw":null,"content":null,"categories":null,"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://holoncaro.github.io/tags/Hexo/"}]},{"title":"MarkDown Tips","slug":null,"date":"2017-03-12T15:01:04.000Z","updated":null,"comments":null,"path":"2017/03/12/MarkDown Tips/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Markdown标记语言的基本语法 1. 一级标题二级标题三级标题四级标题五级标题六级标题2. 无序列表 无序列表 无序列表 有序列表 有序列表 有序列表 3. 这是代表引用 这是二级引用 这是三级引用 4.Github 5.我是粗体我是斜体 6.12var MarkDown = null;console.log(MarkDown); var Tabs = null;console.log(Tabs); 7.我是分割线 我是分割线","raw":null,"content":null,"categories":null,"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://holoncaro.github.io/tags/MarkDown/"}]}]