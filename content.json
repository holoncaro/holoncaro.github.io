[{"title":"Function Execute","slug":null,"date":"2017-03-18T16:05:58.000Z","updated":null,"comments":null,"path":"2017/03/19/Function Execute/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"变量定义提升、this指针、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等知识点 1234function Foo()&#123; getName = function()&#123; console.log(\"No.1\") &#125;; return this;&#125; 构造器函数小结： 函数执行一次，getName这个无var变量才挂载到window对象下。Foo(); getName(); =&gt; No.1 Foo()，返回的this指向window对象。Foo().getName(); =&gt; No.1 new Foo()，返回的this指向新建对象。new Foo().getName() =&gt; undefined 1Foo.getName = function()&#123; console.log(\"No.2\") &#125;; 创建Foo对象的静态属性getName，存储一个匿名函数： Foo.getName(); =&gt; No.2 对象层面的一个属性. 1Foo.prototype.getName = function()&#123; console.log(\"No.3\") &#125;; 构造器原型上的getName方法: new Foo().getName() =&gt; No.3 1var getName = function()&#123; console.log(\"No.4\") &#125;; 函数表达式赋值： 函数不提前，变量提前.var getName; getName = function(){ ** }; 1function getName()&#123; console.log(\"No.5\") &#125;; 函数申明： 函数体提前。 function Foo(){ getName = function(){ console.log(“No.1”) }; return this; } Foo.getName = function(){ console.log(“No.2”) }; Foo.prototype.getName = function(){ console.log(“No.3”) }; var getName = function(){ console.log(“No.4”) }; function getName(){ console.log(“No.5”) }; Foo.getName(); =&gt;No.2 getName(); =&gt;No.4 Foo().getName(); =&gt;No.1 getName(); =&gt;1 new Foo.getName(); =&gt;No.2 new Foo().getName(); =&gt;No.3 new new Foo().getName(); =&gt;No.3 解析：123456789function Foo()&#123; getName = function()&#123; console.log(\"No.1\") &#125;; return this;&#125;var getName; //申明提前function getName()&#123; console.log(\"No.5\") &#125;; //申明提前Foo.getName = function()&#123; console.log(\"No.2\") &#125;;Foo.prototype.getName = function()&#123; console.log(\"No.3\") &#125;;getName = function()&#123; console.log(\"No.4\") &#125;; No.2 ==&gt; No.4(先是No.5) ==&gt;","raw":null,"content":null,"categories":null,"tags":[{"name":"Js","slug":"Js","permalink":"https://holoncaro.github.io/tags/Js/"}]},{"title":"JSON","slug":null,"date":"2017-03-15T11:31:47.000Z","updated":null,"comments":null,"path":"2017/03/15/JSON/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"JSON JavaScript Object Notation，JS对象表示法，其为数据结构，不是编程语言。针对JSON，有序列化器和解析器。 1.JSON可以表示三种类型值： 简单值(string 必须双引号, number, boolean, null, 无undefined) 对象 数组 12345&#123; \"name\": \"Holoncaro\", \"isMale\": true, \"age\": 28&#125; 对象和数组通常是JSON数据结构的最外层形式，JSON不支持变量、函数、对象实例。 2. 全局JSON对象，有两个对象方法 stringify() 和 parse() ，用于将对象序列化为JSON字符串及将JSON解析为原生JS值。 123456789var arr = &#123; name: 'Holoncaro', age: undefined, hobby: null, loveNum: 2, sayHi : function()&#123; return this.name; &#125;&#125; 将上面Js对象进行各种序列化： 直接序列化(undefined和function会被抛弃)1console.log(JSON.stringify(arr)) 输出的结果为 {&quot;name&quot;:&quot;Holoncaro&quot;,&quot;hobby&quot;:null,&quot;loveNum&quot;:2} 带过滤数组的序列化1console.log(JSON.stringify(arr,[\"name\"])) 输出的结果为 {&quot;name&quot;:&quot;Holoncaro&quot;} 带过滤函数的序列化123456789101112JSON.stringify(arr, function(key, value)&#123; switch(key)&#123; case \"name\": return 'Hi'+value; case \"age\": return 25; case \"loveNum\": return undefined; default: return value; &#125;&#125;) 输出的结果为 {&quot;name&quot;:&quot;HiHoloncaro&quot;,&quot;age&quot;:25,&quot;hobby&quot;:null} 3. ‘JSON.stingify()’第三个参数，使字符串保持缩进。 1console.log(JSON.stringify(obj,null,2)); 输出的结果为 { &quot;name&quot;: &quot;Holoncaro&quot;, &quot;isMale&quot;: true, &quot;age&quot;: 28 } 4. 如果对象里定义了toJSON()方法，则使用JSON.stringify()时，自动调用toJSON()。","raw":null,"content":null,"categories":null,"tags":[{"name":"JSON","slug":"JSON","permalink":"https://holoncaro.github.io/tags/JSON/"},{"name":"《Js高级程序设计》","slug":"《Js高级程序设计》","permalink":"https://holoncaro.github.io/tags/《Js高级程序设计》/"}]},{"title":"Hexo & Github Deploy Static Blog","slug":null,"date":"2017-03-14T15:45:17.000Z","updated":null,"comments":null,"path":"2017/03/14/Hexo & Github Deploy Static Blog/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"前期准备 电脑装有NodeJs、Git，注册了Github账户。 Hexo：简单来说，就是一款快速生成博客框架的插件； Github： 代码托管、社交编程网站，顺便将Repo仓库里代码生成可视页面，须有index.html默认入口文件； NodeJs： 基于Chrome的V8引擎提取出的JavaScript语言的运行环境，这里主要运行npm； Git： 代码版本管理工具，这儿用于本地代码上传至github服务器保存。 博客雏形 在Git-bash中运行下面指令(配置好npm环境变量)，安装hexo这个node_module `npm install hexo-cli --global` 新建一个文件夹/folder，在其中打开Git-bash，运行命令，/folder文件夹中自动生成需要的框架： `hexo init ` 根据package.json，自动安装hexo运行所依赖的所有包，生成node_modules文件夹(时间稍长，此步建议翻墙): `npm install` 可以先在本地跑下博客雏形，在/folder中打开Git-bash，运行指令: `hexo generate` 生成public文件夹，即静态页面生成，然后运行下面指令，启动本地服务器(127.0.0.1:4000) `hexo server` 在Git-bash中Ctrl+C可以停止本地服务器 Github仓库 在Github中创建名为: YourName.github.io的repository，其中YourName为用户名。 开始部署 在/folder文件夹中Git-bash运行下面指令(–save为了将包信息保存在package.json中): `npm install hexo-deployer-git --save` 修改_config.yml文件中配置： deploy: type: git repository: https://github.com/YourName/YourName.github.io branch: master 再用Git-bash挨个输入下面指令 `hexo clean` 清除上次自动生成的静态博客 `hexo generate` 再次生成新的静态博客 `hexo deploy` 同步部署到github的YourName.github.io仓库 如果没有配置SSH的话，过程中应该要输入用户名和密码进行确认，不然随意同步别人的仓库岂不乱套了。 发表文章 输入下面指令，在/folder/source/_post中生成后缀为.md的轻标记类型文章: `hexo new &quot;Article Title&quot;` 新建页面，在/folder/source中多了文件夹，其中还有个index.md入口文件: `hexo new page &quot;页面名称&quot;` 写完博文需要与Github同步，这样访问YourName.github.io就可以访问了: `hexo clean` `hexo generate` `hexo deploy` 切换主题 …未完待续","raw":null,"content":null,"categories":null,"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://holoncaro.github.io/tags/Hexo/"}]},{"title":"MarkDown Tips","slug":null,"date":"2017-03-12T15:01:04.000Z","updated":null,"comments":null,"path":"2017/03/12/MarkDown Tips/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"1. 一级标题二级标题三级标题四级标题五级标题六级标题 2. 无序列表 无序列表 无序列表 有序列表 有序列表 有序列表 3. 这是代表引用 这是二级引用 这是三级引用 4.Github 5.我是粗体我是斜体 6.12var MarkDown = null;console.log(MarkDown); var Tabs = null;console.log(Tabs); 7.我是分割线 我是分割线","raw":null,"content":null,"categories":null,"tags":[{"name":"markdown","slug":"markdown","permalink":"https://holoncaro.github.io/tags/markdown/"}]}]