[{"title":"Gulp","slug":null,"date":"2017-03-19T11:51:12.000Z","updated":null,"comments":null,"path":"2017/03/19/Gulp/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Gulp：自动化构建工具，实质就是完成机械的重复的工作。实现LESS/SASS编译、压缩、合并，JS合并、压缩、混淆，img压缩复制，html压缩等。 npm init 回答一系列问题之后，生成package.json文件（包管理）。 npm install gulp --save-dev 等等等…生成node_modules的，里面有gulp包。同时package.json里加入开发包依赖。 gulp主文件 gulpfile.js(文件名固定)，用于注册任务。 123456//引入Gulp模块var gulp = require('gulp');//注册一个任务gulp.task('say', function()&#123; //执行say任务的代码&#125;) 原代码文件src / 发布文件dist(distribution) 转存文件gulp.src取文件，gulp.dest放置文件。 12gulp.src('src/index.html') .pipe(gulp.dest('dist/')); 监视任务 1gulp.watch('src/index.html',['copy']) 手动触发主任务，然后监视文件触发子任务 Gulp插件 Less编译，CSS压缩编译：npm install gulp-less --save-dev压缩：npm install gulp-cssnano --save-dev合并的话，可以用Less的@import导包方法，前下划线_demo.less不进管道 123456789var less = require('gulp-less');var cssnano = require('gulp-cssnano');//注册一个任务gulp.task('style', function()&#123; gulp.src('src/style/*.less') .pipe(less()) .pipe(cssnano()) .pipe(gulp.dest('dist/style'))&#125;) 此时可以在dist任务中，增加一个监视。 JS合并、压缩、混淆先合并，后混淆 1234567var concat = require('gulp-concat');gulp.task('script', function()&#123; gulp.src('src/scripts/*.js') .pipe(concat('all.js')) .pipe(uglify()) //压缩混淆均由uglify()处理 .pipe(gulp.dest('dist/scripts/'))&#125;) IMG复制 1234gulp.task('image', function()&#123; gulp.src('src/images/*.*') .pipe(gulp.dest('dist/images/'))&#125;) HTML复制 123456789var htmlmin = require('gulp-htmlmin');gulp.task('html', function()&#123; gulp.src('src/*.html') .pipe(htmlmin(&#123; collapseWhitespace: true, //删除空白分行 removeComments: true //删除注释 &#125;)) .pipe(gulp.dest('dist/'))&#125;) browser-sync同步各浏览器动作，进行差异测试npm install browser-sync --save-dev 12345678910var browserSync = require('browser-sync').create();gulp.task('serve', function()&#123; browserSync.init(&#123; server: &#123;baseDir:'./dist/'&#125; &#125;) gulp.watch('src/style/*.less', ['style']); gulp.watch('src/scripts/*.js', ['script']); ...&#125;) 常用插件[编译Less: gulp-less][创建本地服务器: browser-sync][合并文件: gulp-concat][最小化js文件: gulp-uglify][重命名文件: gulp-raname][最小化CSS文件: gulp-cssnano][压缩html文件: gulp-minify-html][最小化图像: gulp-imagemin]","raw":null,"content":null,"categories":null,"tags":[{"name":"gulp","slug":"gulp","permalink":"https://holoncaro.github.io/tags/gulp/"}]},{"title":"Function Execute(函数调用顺序解析)","slug":null,"date":"2017-03-18T16:05:58.000Z","updated":null,"comments":null,"path":"2017/03/19/Function Execute/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"变量定义提升、this指针、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等知识点 123456function Foo()&#123; getName = function()&#123; console.log(\"No.1\") &#125;; return this;&#125; 构造器函数小结： 函数执行一次，getName这个无var变量才挂载到window对象下。Foo(); getName(); =&gt; No.1 Foo()，返回的this指向window对象。Foo().getName(); =&gt; No.1 new Foo()，返回的this指向新建对象。new Foo().getName() =&gt; undefined 123Foo.getName = function()&#123; console.log(\"No.2\")&#125;; 创建Foo对象的静态属性getName，存储一个匿名函数： Foo.getName(); =&gt; No.2 对象层面的一个属性。 123Foo.prototype.getName = function()&#123; console.log(\"No.3\")&#125;; 构造器原型上的getName方法: new Foo().getName() =&gt; No.3 123var getName = function()&#123; console.log(\"No.4\")&#125;; 函数表达式赋值： 函数不提前，变量提前.var getName; getName = function(){ ** }; 123function getName()&#123; console.log(\"No.5\")&#125;; 函数申明： 函数体提前。 经典题目，根据各种定义的函数，得出输各值出顺序：12345678910111213141516171819202122function Foo()&#123; getName = function()&#123; console.log(\"No.1\") &#125;; return this;&#125; Foo.getName = function()&#123; console.log(\"No.2\")&#125;; Foo.prototype.getName = function()&#123; console.log(\"No.3\")&#125;; var getName = function()&#123; console.log(\"No.4\")&#125;; function getName()&#123; console.log(\"No.5\")&#125;; Foo.getName(); =&gt;No.2 getName(); =&gt;No.4 Foo().getName(); =&gt;No.1 getName(); =&gt;1 new Foo.getName(); =&gt;No.2 new Foo().getName(); =&gt;No.3 new new Foo().getName(); =&gt;No.3 JavaScript解析后，实际执行顺序如下分析：123456789function Foo()&#123; getName = function()&#123; console.log(\"No.1\") &#125;; return this;&#125;var getName; //变量声明提前function getName()&#123; console.log(\"No.5\") &#125;; //函数声明提前Foo.getName = function()&#123; console.log(\"No.2\") &#125;;Foo.prototype.getName = function()&#123; console.log(\"No.3\") &#125;;getName = function()&#123; console.log(\"No.4\") &#125;; Foo.getName();—Foo对象的getName属性，题目中如果没有function Foo(){ ** }，是无法定义Foo.getName = function(){ ** }，因为undefined不能有属性。 ==&gt; No.2 getName();—普通的函数调用，因为申明提前，同名函数后面覆盖前面的。 ==&gt; No.4 Foo().getName();—Foo()调用后，查找getName，Foo()函数里没有定义，爬到上层继续查找，找到console.log(&quot;No.4&quot;)，覆盖之！ ==&gt; No.1 getName();—已经被上个覆盖了,所以调用仍返回相同的。 ==&gt; No.1 new Foo.getName();—等同于new (Foo.getName())，仅仅是将其作为构造函数执行。 ==&gt; No.2 new Foo().getName();—new Foo()调用后，返回的是一个构造器创建的新对象，这类对象上都有prototype上继承来的属性和方法。 ==&gt; No.3 new new Foo().getName();—等同于new((new Foo()).getName)(),先执行(new Foo()).getName，为实例对象上的getName函数本身，再将函数本身作为构造函数new(function(){ ** })() ==&gt; No.3","raw":null,"content":null,"categories":null,"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://holoncaro.github.io/tags/JavaScript/"}]},{"title":"JSON","slug":null,"date":"2017-03-15T11:31:47.000Z","updated":null,"comments":null,"path":"2017/03/15/JSON/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"JSON JavaScript Object Notation，JS对象表示法，其为数据结构，不是编程语言。针对JSON，有序列化器和解析器。 1.JSON可以表示三种类型值： 简单值(string 必须双引号, number, boolean, null, 无undefined) 对象 数组 12345&#123; \"name\": \"Holoncaro\", \"isMale\": true, \"age\": 28&#125; 对象和数组通常是JSON数据结构的最外层形式，JSON不支持变量、函数、对象实例。 2. 全局JSON对象，有两个对象方法 stringify() 和 parse() ，用于将对象序列化为JSON字符串及将JSON解析为原生JS值。 123456789var arr = &#123; name: 'Holoncaro', age: undefined, hobby: null, loveNum: 2, sayHi : function()&#123; return this.name; &#125;&#125; 将上面Js对象进行各种序列化： 直接序列化(undefined和function会被抛弃)1console.log(JSON.stringify(arr)) 输出的结果为 {&quot;name&quot;:&quot;Holoncaro&quot;,&quot;hobby&quot;:null,&quot;loveNum&quot;:2} 带过滤数组的序列化1console.log(JSON.stringify(arr,[\"name\"])) 输出的结果为 {&quot;name&quot;:&quot;Holoncaro&quot;} 带过滤函数的序列化123456789101112JSON.stringify(arr, function(key, value)&#123; switch(key)&#123; case \"name\": return 'Hi'+value; case \"age\": return 25; case \"loveNum\": return undefined; default: return value; &#125;&#125;) 输出的结果为 {&quot;name&quot;:&quot;HiHoloncaro&quot;,&quot;age&quot;:25,&quot;hobby&quot;:null} 3. ‘JSON.stingify()’第三个参数，使字符串保持缩进。 1console.log(JSON.stringify(obj,null,2)); 输出的结果为 { &quot;name&quot;: &quot;Holoncaro&quot;, &quot;isMale&quot;: true, &quot;age&quot;: 28 } 4. 如果对象里定义了toJSON()方法，则使用JSON.stringify()时，自动调用toJSON()。","raw":null,"content":null,"categories":null,"tags":[{"name":"JSON","slug":"JSON","permalink":"https://holoncaro.github.io/tags/JSON/"},{"name":"《Js高级程序设计》","slug":"《Js高级程序设计》","permalink":"https://holoncaro.github.io/tags/《Js高级程序设计》/"}]},{"title":"Hexo & Github Deploy Static Blog","slug":null,"date":"2017-03-14T15:45:17.000Z","updated":null,"comments":null,"path":"2017/03/14/Hexo & Github Deploy Static Blog/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"前期准备 电脑装有NodeJs、Git，注册了Github账户。 Hexo：简单来说，就是一款快速生成博客框架的插件； Github： 代码托管、社交编程网站，顺便将Repo仓库里代码生成可视页面，须有index.html默认入口文件； NodeJs： 基于Chrome的V8引擎提取出的JavaScript语言的运行环境，这里主要运行npm； Git： 代码版本管理工具，这儿用于本地代码上传至github服务器保存。 博客雏形 在Git-bash中运行下面指令(配置好npm环境变量)，安装hexo这个node_module `npm install hexo-cli --global` 新建一个文件夹/folder，在其中打开Git-bash，运行命令，/folder文件夹中自动生成需要的框架： `hexo init ` 根据package.json，自动安装hexo运行所依赖的所有包，生成node_modules文件夹(时间稍长，此步建议翻墙): `npm install` 可以先在本地跑下博客雏形，在/folder中打开Git-bash，运行指令: `hexo generate` 生成public文件夹，即静态页面生成，然后运行下面指令，启动本地服务器(127.0.0.1:4000) `hexo server` 在Git-bash中Ctrl+C可以停止本地服务器 Github仓库 在Github中创建名为: YourName.github.io的repository，其中YourName为用户名。 开始部署 在/folder文件夹中Git-bash运行下面指令(–save为了将包信息保存在package.json中): `npm install hexo-deployer-git --save` 修改_config.yml文件中配置： deploy: type: git repository: https://github.com/YourName/YourName.github.io branch: master 再用Git-bash挨个输入下面指令 `hexo clean` 清除上次自动生成的静态博客 `hexo generate` 再次生成新的静态博客 `hexo deploy` 同步部署到github的YourName.github.io仓库 如果没有配置SSH的话，过程中应该要输入用户名和密码进行确认，不然随意同步别人的仓库岂不乱套了。 发表文章 输入下面指令，在/folder/source/_post中生成后缀为.md的轻标记类型文章: `hexo new &quot;Article Title&quot;` 新建页面，在/folder/source中多了文件夹，其中还有个index.md入口文件: `hexo new page &quot;页面名称&quot;` 写完博文需要与Github同步，这样访问YourName.github.io就可以访问了: `hexo clean` `hexo generate` `hexo deploy` 切换主题 …未完待续","raw":null,"content":null,"categories":null,"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://holoncaro.github.io/tags/Hexo/"}]},{"title":"MarkDown Tips","slug":null,"date":"2017-03-12T15:01:04.000Z","updated":null,"comments":null,"path":"2017/03/12/MarkDown Tips/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"1. 一级标题二级标题三级标题四级标题五级标题六级标题 2. 无序列表 无序列表 无序列表 有序列表 有序列表 有序列表 3. 这是代表引用 这是二级引用 这是三级引用 4.Github 5.我是粗体我是斜体 6.12var MarkDown = null;console.log(MarkDown); var Tabs = null;console.log(Tabs); 7.我是分割线 我是分割线","raw":null,"content":null,"categories":null,"tags":[{"name":"markdown","slug":"markdown","permalink":"https://holoncaro.github.io/tags/markdown/"}]}]